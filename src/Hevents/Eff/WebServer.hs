module Hevents.Eff.WebServer where


import           Control.Category
import           Control.Concurrent.Async
import           Control.Eff
import           Control.Monad.Except
import           Network.Wai.Handler.Warp as W
import           Prelude                  hiding ((.))
import           Servant
import           Servant.Utils.Enter

-- | Extend a *natural transformation* from some effectful computation to IO into the `EitherT` monad expected by servant.
effToHandle :: (Eff r :~> IO) -> (Eff r :~> ExceptT ServantErr IO)
effToHandle = (liftNat .)

-- Some type aliases to simplify things...
type EffServer api r = ServerT api (Eff r)
type EffToServant r = Eff r :~> ExceptT ServantErr IO

-- | Serve given API with witness `p` implemented by handler `hdl` and  starting server on given `port`.
-- The actual server is built by applying the given transformation `eff` to build an actual `Server api` handler.
runWebServer :: (HasServer api '[], Enter (EffServer api r) (EffToServant r) (Server api))
             => Port -> Proxy api -> (Eff r :~> IO) -> ServerT api (Eff r) -> IO (Async ())
runWebServer port p eff hdl = async $ W.run port $ serve p hdler
  where
    hdler = enter (effToHandle eff) hdl

-- | Run web server on port `port` serving API with withness `p` applying transformation `eff` which already takes into
-- account Servant errors.
--
-- This is similar to `runWebServer` except that this allows to pass an effectful interpreter that can intercept
-- errors generated by Servant.
runWebServerErr :: (HasServer api '[], Enter (EffServer api r) (EffToServant r) (Server api))
             => Port -> Proxy api -> (Eff r :~> ExceptT ServantErr IO) -> ServerT api (Eff r) -> IO (Async ())
runWebServerErr port p eff hdl = async $ W.run port $ serve p hdler
  where
    hdler = enter eff hdl


