module Hevents.Eff.WebServer where


import           Control.Category
import           Control.Concurrent.Async
import           Control.Eff
import           Control.Monad.Except
import           Network.Socket
import           Network.Wai.Handler.Warp as W
import           Prelude                  hiding ((.))
import           Servant
import           Servant.Utils.Enter

-- | Extend a *natural transformation* from some effectful computation to IO into the `EitherT` monad expected by servant.
effToHandle :: (Eff r :~> IO) -> (Eff r :~> ExceptT ServantErr IO)
effToHandle = (liftNat .)

-- Some type aliases to simplify things...
type EffServer api r = ServerT api (Eff r)
type EffToServant r = Eff r :~> ExceptT ServantErr IO

-- | Serve given API with witness `p` implemented by handler `hdl` and  starting server on given `port`.
-- The actual server is built by applying the given transformation `eff` to build an actual `Server api` handler.
runWebServer :: (HasServer api '[], Enter (EffServer api r) (EffToServant r) (Server api))
             => Port -> Proxy api -> (Eff r :~> IO) -> ServerT api (Eff r) -> IO (Async ())
runWebServer port p eff hdl = async $ W.run port $ serve p hdler
  where
    hdler = enter (effToHandle eff) hdl

-- | Run web server on port `port` serving API with withness `p` applying transformation `eff` which already takes into
-- account Servant errors.
--
-- This is similar to `runWebServer` except that this allows to pass an effectful interpreter that can intercept
-- errors generated by Servant.
runWebServerErr :: (HasServer api '[], Enter (EffServer api r) (EffToServant r) (Server api))
             => Port -> Proxy api -> (Eff r :~> ExceptT ServantErr IO) -> ServerT api (Eff r) -> IO (Async ())
runWebServerErr port p eff hdl = async $ W.run port $ serve p hdler
  where
    hdler = enter eff hdl


-- | Run web server on a random port and returns it
runWebServerOnFreePort :: (HasServer api '[], Enter (EffServer api r) (EffToServant r) (Server api))
             => Proxy api -> (Eff r :~> ExceptT ServantErr IO) -> ServerT api (Eff r) -> IO (Port, Async ())
runWebServerOnFreePort p eff hdl = do
  sock   <- mkTCPSocket
  port   <- socketPort sock
  thread <- async $ W.runSettingsSocket defaultSettings sock $ serve p hdler
  return (fromIntegral port, thread)
  where
    hdler = enter eff hdl

    mkTCPSocket :: IO Socket
    mkTCPSocket = do
      sock <- socket AF_INET Stream defaultProtocol
      bind sock (SockAddrInet aNY_PORT iNADDR_ANY)
      listen sock 5
      return sock
